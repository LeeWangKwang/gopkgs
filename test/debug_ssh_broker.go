
package main

import (
	//"bytes"
	//"bufio"
	"flag"
    "fmt"
	"os"
	"strings"

	"codecloud.web.att.com/gopkgs/ssh_broker"

)


/*
	run a local script --  run as a go routine to run multiple in parallel
*/
func test_script( broker *ssh_broker.Broker, ch chan int, host *string, script *string, parms *string ) {

	fmt.Fprintf( os.Stderr, "running commnand parms=%s\n", *parms )
	stdout, stderr, err := broker.Run_on_host( *host, *script, *parms )
	if err != nil {
		fmt.Fprintf( os.Stderr, "command failed: %s:  %s \n", *host, err )
		fmt.Fprintf( os.Stderr, "%s", stderr.String() )
	} else {
		fmt.Fprintf( os.Stderr, "command was successful:\n" )
		fmt.Printf( "%s\n", stdout.String() )	
	}

	fmt.Fprintf( os.Stderr, "go routine done:%s \n", *parms )
	ch <- 1

	return
}
/*
	run a command --  run as a go routine to run multiple in parallel
*/
func test_cmd( broker *ssh_broker.Broker, ch chan int, host *string, cmd *string ) {

	fmt.Fprintf( os.Stderr, "running commnand %s\n", *cmd )
	stdout, stderr, err := broker.Run_cmd( *host, *cmd )
	if err != nil {
		fmt.Fprintf( os.Stderr, "command failed: %s:  %s \n", *host, err )
		fmt.Fprintf( os.Stderr, "%s", stderr.String() )
	} else {
		fmt.Fprintf( os.Stderr, "command was successful:\n" )
		fmt.Printf( "%s\n", stdout.String() )	
	}

	fmt.Fprintf( os.Stderr, "go routine done:%s \n", *cmd )
	ch <- 1

	return
}

/*
	Run as a goroutine to handle responses that are generated by
	asynch request submission.
*/
func handle_responses( ch chan int, rch chan *ssh_broker.Broker_msg ) {
	for {
		msg, is_open := <- rch
		if !is_open {
			fmt.Fprintf( os.Stderr, "ssh response channel was closed!\n" )
			os.Exit( 1 )
		}

		stdout, stderr, err := msg.Get_results( )
		host, script, id := msg.Get_info( )
		fmt.Fprintf( os.Stderr, "received response host=%s script=%s id=%d\n", host, script, id )
		if err != nil {
			fmt.Fprintf( os.Stderr, "command failed: %s:  %s \n", host, err )
			fmt.Fprintf( os.Stderr, "%s", stderr.String() )
		} else {
			fmt.Fprintf( os.Stderr, "command was successful:\n" )
			fmt.Printf( "%s\n", stdout.String() )	
		}
	
		ch <- 1						// signal to main that one command finished
	}
}

func main( ) {
	var ch chan int
	var rch chan *ssh_broker.Broker_msg		// response channel
	var err error

	asynch := flag.Bool( "a", false, "asynch processing" )
	cmd := flag.String( "c", "", "command to execute" )
	host_list := flag.String( "h", "localhost", "host name" )
	parms := flag.String( "p", "", "parms" )
	parallel := flag.Int( "P", 1, "parallel scripts" )
	script := flag.String( "s", "test_script", "script to execute" )
	flag.Parse()

	keys := []string { "key" }
	broker := ssh_broker.Mk_broker( "scooter", keys )
	if broker == nil {
		fmt.Fprintf( os.Stderr, "unable to create an ssh broker\n" )
		os.Exit( 1 )
	}
	defer broker.Close( )
	broker.Start_initiators( 30 )				// start three more initiators

	ch = make( chan int, 10 )					// goroutine writes back to us on this
	if *asynch {
		rch = make( chan *ssh_broker.Broker_msg, 10 )	
		go handle_responses( ch, rch )
	}

	host := strings.Split( *host_list, "," )

	wait4 := 0
	for i := 0; i < *parallel; i++  {
		for j := range host {
			wait4++
			p := fmt.Sprintf( "%s %d", *parms,  i )
			if ! *asynch {
				if *cmd == "" {
					go test_script( broker, ch, &host[j], script, &p )
				} else {
					go test_cmd( broker, ch, &host[j], cmd )
				}
			} else {
				fmt.Fprintf( os.Stderr, "running asynch commnand parms=%s\n", p )
				if *cmd == "" {					// -c supplied
					err = broker.NBRun_on_host( host[j], *script, p, (i*100)+j, rch )
				} else {
					err = broker.NBRun_cmd( host[j], *cmd, (i*100)+j, rch )
				}
				if err != nil {
					fmt.Fprintf( os.Stderr, "asynch commnand submit failed: parms=%s: %s\n", host[j], p, err )
				}
			}
		}
	} 

	for i := 0; i < wait4; i++ {
		fmt.Fprintf( os.Stderr, "waiting for %d to finish\n", wait4 - i )
		<- ch
	}
	
}
