/*
	Mnemonic:	debug_ssh_broker.go
	Abstract:	More than just functional tests that might be provided in a *_test.go
				module, this provides an end to end test of the ssh_broker.
	Author:		E. Scott Daniels
	Date:		23 December 2014
*/

package main

import (
	//"bytes"
	//"bufio"
	"flag"
    "fmt"
	"os"
	"strings"

	"codecloud.web.att.com/gopkgs/ssh_broker"		// CAUTION: ssh_broker requires a fairly recent version of go
)


/*
	run a local script --  run as a go routine to run multiple in parallel
*/
func test_script( broker *ssh_broker.Broker, ch chan int, host *string, script *string, parms *string, env_file *string ) {

	fmt.Fprintf( os.Stderr, "running commnand=%s parms=%s\n", *script, *parms )
	stdout, stderr, err := broker.Run_on_host( *host, *script, *parms, *env_file )
	if err != nil {
		fmt.Fprintf( os.Stderr, "command failed: %s:  %s \n", *host, err )
		fmt.Fprintf( os.Stderr, "%s", stderr.String() )
	} else {
		fmt.Fprintf( os.Stderr, "command was successful:\n" )
		fmt.Printf( "%s\n", stdout.String() )	
	}

	fmt.Fprintf( os.Stderr, "go routine done:%s \n", *parms )
	ch <- 1

	return
}

/*
	run a command --  run as a go routine to run multiple in parallel
*/
func test_cmd( broker *ssh_broker.Broker, ch chan int, host *string, cmd *string ) {

	fmt.Fprintf( os.Stderr, "test_cmd: running commnand %s\n", *cmd )
	stdout, stderr, err := broker.Run_cmd( *host, *cmd )
	if err != nil {
		fmt.Fprintf( os.Stderr, "command failed: %s:  %s \n", *host, err )
		fmt.Fprintf( os.Stderr, "%s", stderr.String() )
	} else {
		fmt.Fprintf( os.Stderr, "command was successful:\n" )
		fmt.Printf( "%s\n", stdout.String() )	
	}

	fmt.Fprintf( os.Stderr, "go routine done: %s \n", *cmd )
	ch <- 1

	return
}

/*
	Run as a goroutine to handle responses that are generated by
	asynch request submission.
*/
func handle_responses( ch chan int, rch chan *ssh_broker.Broker_msg ) {
	for {
		msg, is_open := <- rch
		if !is_open {
			fmt.Fprintf( os.Stderr, "ssh response channel was closed!\n" )
			os.Exit( 1 )
		}

		stdout, stderr, err := msg.Get_results( )
		host, script, id := msg.Get_info( )
		fmt.Fprintf( os.Stderr, "received response host=%s script=%s id=%d\n", host, script, id )
		if err != nil {
			fmt.Fprintf( os.Stderr, "command failed: %s:  %s \n", host, err )
			fmt.Fprintf( os.Stderr, "%s", stderr.String() )
		} else {
			fmt.Fprintf( os.Stderr, "command was successful:\n" )
			fmt.Printf( "%s\n", stdout.String() )	
		}
	
		ch <- 1						// signal to main that one command finished
	}
}

func main( ) {
	var ch chan int
	var rch chan *ssh_broker.Broker_msg		// response channel
	var err error
	var user *string

	def_user := os.Getenv( "USER" )
	def_key := os.Getenv( "HOME" ) + "/.ssh/id_dsa"

	asynch := flag.Bool( "a", false, "asynch processing" )
	cmd := flag.String( "c", "", "command to execute" )
	env_file := flag.String( "e", "", "environment file for script" )
	host_list := flag.String( "h", "localhost", "host name" )
	key := flag.String( "k", def_key, "key file" )
	parms := flag.String( "p", "", "parms" )
	parallel := flag.Int( "P", 1, "parallel scripts" )
	rsync := flag.String( "r", "", "rsync files:dir" )
	script := flag.String( "s", "test_script", "script to execute" )
	user = flag.String ( "u", def_user, "user name" )
	flag.Parse()

	if *key == "" {
		home := os.Getenv( "HOME" )
		k := fmt.Sprintf( "%s/.ssh/id_rsa", home )
		_, err = os.Stat( k )
		if err != nil {
			k = fmt.Sprintf( "%s/.ssh/id_dsa", home )
			_, err = os.Stat( k )
			if err != nil {
				fmt.Fprintf( os.Stderr, "cannot find default key file ~/.ssh/id_dsa\n" )
				os.Exit( 1 )
			}
		}
		key = &k
	}

	keys := []string { *key }
	broker := ssh_broker.Mk_broker( *user, keys )
	if broker == nil {
		fmt.Fprintf( os.Stderr, "unable to create an ssh broker\n" )
		os.Exit( 1 )
	}
	defer broker.Close( )
	broker.Start_initiators( 30 )				// start three more initiators

	ch = make( chan int, 10 )					// goroutine writes back to us on this
	if *asynch {
		rch = make( chan *ssh_broker.Broker_msg, 10 )	
		go handle_responses( ch, rch )
	}

	if *rsync != "" {
		toks := strings.Split( *rsync, ":" )		// assume file,file,file:dest_dir
		if len( toks ) != 2 {
			fmt.Fprintf( os.Stderr, "bad rsynch string, expected file,file,file...:destdir\n" )
			os.Exit( 1 )
		}

		broker.Add_rsync( &toks[0], &toks[1] )
		broker.Set_verbose( true )
	}

	host := strings.Split( *host_list, "," )

	wait4 := 0
	for i := 0; i < *parallel; i++  {
		for j := range host {
			wait4++
			if ! *asynch {
				if *cmd == "" {
					fmt.Fprintf( os.Stderr, "running synch script parms=%s\n", *parms )
					go test_script( broker, ch, &host[j], script, parms, env_file )
				} else {
					fmt.Fprintf( os.Stderr, "running synch commnand %s\n", *cmd )
					go test_cmd( broker, ch, &host[j], cmd )
				}
			} else {
				fmt.Fprintf( os.Stderr, "running asynch commnand parms=%s\n", *parms )
				if *cmd == "" {					// -c not supplied
					err = broker.NBRun_on_host( host[j], *script, *parms, (i*100)+j, rch )
				} else {
					err = broker.NBRun_cmd( host[j], *cmd, (i*100)+j, rch )
				}
				if err != nil {
					fmt.Fprintf( os.Stderr, "asynch commnand submit failed: parms=%s: %s\n", host[j], *parms, err )
				}
			}
		}
	} 

	for i := 0; i < wait4; i++ {
		fmt.Fprintf( os.Stderr, "waiting for %d to finish\n", wait4 - i )
		<- ch
	}
	
}
