// vi: sw=4 ts=4:
/*
 ---------------------------------------------------------------------------
   Copyright (c) 2013-2015 AT&T Intellectual Property

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at:

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
 ---------------------------------------------------------------------------
*/

/*
	Mnemonic:	debug_ssh_broker.go
	Abstract:	More than just functional tests that might be provided in a *_test.go
				module, this provides an end to end test of the ssh_broker.
	Author:		E. Scott Daniels
	Date:		23 December 2014
	Mods:		              Fixed fmt statement in printf.
				21 Sep 2015 - Added repeat function.
*/

package main

import (
	"flag"
    "fmt"
	"os"
	"strings"
	"time"

	"github.com/att/gopkgs/ssh_broker"		// CAUTION: ssh_broker requires a fairly recent version of go
)


/*
	run a local script --  run as a go routine to run multiple in parallel
*/
func test_script( broker *ssh_broker.Broker, ch chan int, host *string, script *string, parms *string, env_file *string ) {

	fmt.Fprintf( os.Stderr, "running commnand=%s parms=%s\n", *script, *parms )
	stdout, stderr, err := broker.Run_on_host( *host, *script, *parms, *env_file )
	if err != nil {
		fmt.Fprintf( os.Stderr, "command failed: %s:  %s \n", *host, err )
		fmt.Fprintf( os.Stderr, "%s", stderr.String() )
	} else {
		fmt.Fprintf( os.Stderr, "command was successful:\n" )
		fmt.Printf( "%s\n", stdout.String() )	
	}

	fmt.Fprintf( os.Stderr, "go routine done:%s \n", *parms )
	ch <- 1

	return
}

/*
	run a command --  run as a go routine to run multiple in parallel
*/
func test_cmd( broker *ssh_broker.Broker, ch chan int, host *string, cmd *string ) {

	fmt.Fprintf( os.Stderr, "test_cmd: running command %s\n", *cmd )
	stdout, stderr, err := broker.Run_cmd( *host, *cmd )
	if err != nil {
		fmt.Fprintf( os.Stderr, "command failed: %s:  %s \n", *host, err )
		fmt.Fprintf( os.Stderr, "%s", stderr.String() )
	} else {
		fmt.Fprintf( os.Stderr, "command was successful:\n" )
		fmt.Printf( "%s\n", stdout.String() )	
	}

	fmt.Fprintf( os.Stderr, "go routine done: %s \n", *cmd )
	ch <- 1

	return
}

/*
	Run as a goroutine to handle responses that are generated by
	asynch request submission.
*/
func handle_responses( ch chan int, rch chan *ssh_broker.Broker_msg ) {
	for {
		msg, is_open := <- rch
		if !is_open {
			fmt.Fprintf( os.Stderr, "ssh response channel was closed!\n" )
			os.Exit( 1 )
		}

		stdout, stderr, _, err := msg.Get_results( )
		host, script, id := msg.Get_info( )
		fmt.Fprintf( os.Stderr, "received response host=%s script=%s id=%d\n", host, script, id )
		if err != nil {
			fmt.Fprintf( os.Stderr, "command failed: %s:  %s \n", host, err )
			fmt.Fprintf( os.Stderr, "%s", stderr.String() )
		} else {
			fmt.Fprintf( os.Stderr, "command was successful:\n" )
			fmt.Printf( "%s\n", stdout.String() )	
		}
	
		ch <- 1						// signal to main that one command finished
	}
}

func main( ) {
	var ch chan int
	var rch chan *ssh_broker.Broker_msg		// response channel
	var err error
	var user *string

	def_user := os.Getenv( "USER" )
	def_key := os.Getenv( "HOME" ) + "/.ssh/id_dsa"

	asynch := flag.Bool( "a", false, "asynch processing" )
	cmd := flag.String( "c", "", "command to execute" )
	repeat_delay := flag.Int( "d", 30, "repeat delay (seconds)" )
	env_file := flag.String( "e", "", "environment file for script" )
	host_list := flag.String( "h", "localhost", "host name(s) (comma sep)" )
	key := flag.String( "k", def_key, "key file" )
	parms := flag.String( "p", "", "parms" )
	parallel := flag.Int( "P", 1, "parallel scripts" )
	rsync := flag.String( "r", "", "rsync files:dir" )
	repeat := flag.Int( "R", 0, "Repeat n times" )
	script := flag.String( "s", "test_script", "script to execute" )
	user = flag.String ( "u", def_user, "user name" )
	flag.Parse()

	if *key == "" {
		home := os.Getenv( "HOME" )
		k := fmt.Sprintf( "%s/.ssh/id_rsa", home )
		_, err = os.Stat( k )
		if err != nil {
			k = fmt.Sprintf( "%s/.ssh/id_dsa", home )
			_, err = os.Stat( k )
			if err != nil {
				fmt.Fprintf( os.Stderr, "cannot find default key file ~/.ssh/id_dsa\n" )
				os.Exit( 1 )
			}
		}
		key = &k
	}

	keys := []string { *key }
	broker := ssh_broker.Mk_broker( *user, keys )
	if broker == nil {
		fmt.Fprintf( os.Stderr, "unable to create an ssh broker\n" )
		os.Exit( 1 )
	}
	defer broker.Close( )
	broker.Start_initiators( 30 )				// start three more initiators

	ch = make( chan int, 10 )					// goroutine writes back to us on this
	if *asynch {
		rch = make( chan *ssh_broker.Broker_msg, 10 )	
		go handle_responses( ch, rch )
	}

	if *rsync != "" {
		toks := strings.Split( *rsync, ":" )		// assume file,file,file:dest_dir
		if len( toks ) != 2 {
			fmt.Fprintf( os.Stderr, "bad rsynch string, expected file,file,file...:destdir\n" )
			os.Exit( 1 )
		}

		broker.Add_rsync( &toks[0], &toks[1] )
		broker.Set_verbose( true )
	}

	host := strings.Split( *host_list, "," )

	for {
		wait4 := 0
		for i := 0; i < *parallel; i++  {
			for j := range host {
				wait4++
				if ! *asynch {
					if *cmd == "" {
						fmt.Fprintf( os.Stderr, "running synch script parms=%s\n", *parms )
						go test_script( broker, ch, &host[j], script, parms, env_file )
					} else {
						fmt.Fprintf( os.Stderr, "running synch command %s\n", *cmd )
						go test_cmd( broker, ch, &host[j], cmd )
					}
				} else {
					fmt.Fprintf( os.Stderr, "running asynch command on %s parallel=%d parms=%s\n", host[j], i, *parms )
					if *cmd == "" {					// -c not supplied
						err = broker.NBRun_on_host( host[j], *script, *parms, (i*100)+j, rch )
					} else {
						err = broker.NBRun_cmd( host[j], *cmd, (i*100)+j, rch )
					}
					if err != nil {
						fmt.Fprintf( os.Stderr, "asynch command submit failed: host=%s parms=%s: %s\n", host[j], *parms, err )
					}
				}
			}
		}

		for i := 0; i < wait4; i++ {
			fmt.Fprintf( os.Stderr, "waiting for %d to finish\n", wait4 - i )
			<- ch
		}

		if *repeat <= 0 {
			break
		} else {
			fmt.Fprintf( os.Stderr, "delay before repeat: %ds\n", *repeat_delay )
			time.Sleep( time.Second * time.Duration( *repeat_delay ) )
		}

		*repeat--
	}
}
